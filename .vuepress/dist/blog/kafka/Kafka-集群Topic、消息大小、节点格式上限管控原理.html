<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.14" />
    <style>
      :root {
        --c-bg: #fff;
      }

      html.dark {
        --c-bg: #22272e;
      }

      html,
      body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme')
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia('(prefers-color-scheme: dark)').matches
      if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
        document.documentElement.classList.toggle('dark', true)
      }
    </script>
    <title>Kafka 集群 Topic、消息大小、节点格式上限管控原理 | 架构师之路</title><meta name="description" content="记录并分享分布式系统与大数据处理技术的深入理解与实践经验。">
    <link rel="stylesheet" href="/tech-blog/assets/css/styles.ed2a9738.css">
    <link rel="preload" href="/tech-blog/assets/js/runtime~app.d2151947.js" as="script"><link rel="preload" href="/tech-blog/assets/css/styles.ed2a9738.css" as="style"><link rel="preload" href="/tech-blog/assets/js/6484.f9c8e027.js" as="script"><link rel="preload" href="/tech-blog/assets/js/app.92b4cbb5.js" as="script">
    <link rel="prefetch" href="/tech-blog/assets/js/blog_zookeeper_Zookeeper集群节点选举原理实现(三).html.cc1469f4.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/blog_zookeeper_Zookeeper集群如何实现数据一致性和顺序性原理.html.ee753f90.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/blog_zookeeper_Zookeeper集群节点实现通信原理(二).html.b03f7bd1.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/blog_zookeeper_Zookeeper集群广播事务性能如何保证.html.0c93bd65.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/blog_zookeeper_zookeeper-znode数据结构.html.1dc5f71b.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/blog_minio_Minio-上传文件请求负载原理分析.html.6c9e3aba.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/blog_minio_Minio-数据分片多节点存储Java实现.html.2d9feba1.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/blog_zookeeper_Zookeeper集群节点故障剔除、切换、恢复原理.html.c8c8410c.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/blog_minio_Minio-集群生产环境部署示例.html.0f9fa9f3.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/blog_zookeeper_Zookeeper集群节点选举原理实现(二).html.25ad2ccc.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/blog_zookeeper_Zookeeper集群数据视图一致性原理.html.54d07b9a.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/blog_zookeeper_Zookeeper集群Session会话一致性实现原理.html.a63daff0.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/blog_zookeeper_Zookeeper客户端命令行基础操作.html.d1701ed8.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/blog_kafka_Kafka-集群原理设计（二）之源码设计示例分析.html.0fb1fc3f.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/blog_kafka_Kafka-集群Topic之Partion消息可靠性设计（一）.html.97a4b519.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/blog_kafka_Kafka-管理节点Controller设计分析.html.8b92ccea.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/blog_minio_Minio-集群节点是如何实现通信和数据同步的.html.dfedd085.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/blog_zookeeper_Zookeeper集群节点实现通信原理(一).html.6b15bf9a.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/blog_minio_Minio-集群节点并行处理超大文件数据分片上传和存储原理分析.html.cc081fb1.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/blog_kafka_Kafka-集群的数据顺序写入和零拷贝技术设计实现原理.html.6a2007af.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/blog_minio_Minio-集群超大文件上传和异步复制如何确定分块大小.html.7887eddb.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/blog_kafka_Kafka-必备基础知识.html.9d9d3245.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/blog_zookeeper_Zookeeper集群的应用场景.html.431eef69.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/blog_minio_Minio-集群对象版本控制介绍.html.5d6323c3.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/blog_kafka_Kafka-集群Topic、消息大小、节点格式上限管控原理.html.df7d1769.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/blog_minio_Minio-集群是如何处理客户端请求.html.677cbc36.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/blog_zookeeper_Zookeeper集群节点选举原理实现(一).html.7fc912f5.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/blog_kafka_Kafka-集群节点数量的设计.html.d898f236.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/blog_minio_Minio-集群启动过程执行了哪些逻辑.html.edd4a06f.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/blog_kafka_Kafka-集群原理设计（四）之Controller选举和Partition分配.html.6be8ee97.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/blog_minio_Minio-集群数据写入确认消息机制分析.html.e83d7fb5.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/blog_kafka_Kafka-集群原理设计(三)之启动原理介绍.html.22a17e88.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/blog_minio_Minio-集群数据分片如何确认完整性和一致性.html.cd1fd3c9.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/blog_kafka_Kafka-集群节点数量与Partition副本数量关系原理.html.8f5e2137.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/blog_kafka_Kafka-集群状态监测、故障切换机制原理.html.95c07341.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/blog_kafka_Kafka-Stream流处理设计概述.html.d648555d.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/blog_kafka_Kafka-集群Topic之Partion副本同步性能设计（四）.html.e7e9b971.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/blog_minio_Minio-集群事务日志机制介绍.html.4b1c4bdd.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/blog_kafka_Kafka-集群安全认证机制的实现.html.8b931bb3.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/blog_kafka_Kafka-集群Topic之Partion数据写入分布原理设计（六）.html.cf2f4abc.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/blog_minio_Minio-多站点部署_地理容灾和恢复.html.a0054716.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/blog_kafka_Kafka-集群Topic之Partion分布原理设计（三）.html.1587931c.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/blog_minio_Minio-超大文件优化原理分析.html.0df9453a.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/blog_kafka_Kafka-集群Topic之Partion日志分段存储原理设计（五）.html.c7e21379.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/blog_minio_Minio-集群复制队列超大文件（100G）如何存储复制.html.30162973.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/blog_kafka_Kafka-集群Topic之Partion消息可靠性设计（二）.html.510c8bfb.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/blog_minio_Minio-是如何拆分数据多节点存储的.html.e6bc3b72.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/blog_minio_Minio-集群数据备份和数据复制的区别.html.fe8d57bf.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/blog_kafka_Kafka-集群Controller节点和Zookeeper集群leader节点有何区别联系.html.bfccad53.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/blog_kafka_Kafka-的单机、集群部署安装.html.1c422406.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/blog_minio_Minio-集群备份或异地复制如何进行网络带宽限速.html.30208a77.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/blog_minio_Minio-集群冷备数据如何恢复部署.html.118dfcd4.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/blog_kafka_getting-started.html.b1448916.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/blog_kafka_Kafka-集群原理设计和实现概述(一).html.c50ea9ad.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/blog_minio_Minio-集群备份全部数据非特定bucket.html.410fd141.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/blog_kafka_Kafka-集群架构设计原理概述.html.c4142022.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/blog_kafka_Kafka-集群如何处理生产者和消费者处理消息速率差异问题.html.372f6542.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/blog_kafka_Kafka-Topic之Zookeeper数据内容介绍.html.abc092fe.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/blog_minio_Minio-集群安全管控实现原理分析.html.cbac2733.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/blog_zookeeper_zookeeper集群部署安装.html.901dfbc1.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/blog_minio_Minio-单机和集群部署模式.html.1e59a15e.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/blog_minio_Minio-灾难恢复操作与原理分析.html.f91d3311.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/blog_minio_Minio-架构师必备掌握知识点概览.html.16f852e5.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/blog_minio_Minio-分布式锁实现机制.html.39e85614.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/blog_kafka_Kafka-集群生产性能调优业务场景.html.a1483387.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/blog_minio_Minio-学习目标.html.243dfabc.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/blog_kafka_Kafka-集群元数据之Zookeeper存储介绍.html.c68aebde.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/blog_minio_Minio-基础知识和架构设计概览.html.9f24d052.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/blog_minio_Minio-集群部署为什么至少4个节点.html.75828603.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/blog_kafka_Kafka-集群为什么依赖zookeeper.html.0ae30512.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/blog_minio_getting-started.html.7e0fa1b6.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/blog_minio_Minio-集群数据备份如何进行冷备.html.a8bc8b75.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/blog_zookeeper_getting-started.html.2e81e656.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/blog_kafka_Kafka-组件架构师需要掌握哪些要点.html.5a47e97d.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/blog_minio_Minio-跨中心集群为什么采用异步复制而非构建一个超大集群.html.57c41adc.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/blog_kafka_Kafka-学习目标.html.555b1edf.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/blog_minio_Minio-集群是如何实现异步复制.html.e3133a82.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/blog_kafka_Kafka-集群和Zookeeper集群架构设计对比分析.html.bff81b9e.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/blog_zookeeper_Zookeeper学习目标.html.06852036.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/blog_minio_Minio-无中心节点集群与有中心节点集群优缺点.html.eae6b85a.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/geting-started.html.6ce9d0b0.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/index.html.df3d9c9c.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/tag_分布式管理_index.html.e14ac87f.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/tag_对象存储_index.html.e6d6d752.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/tag_消息队列_index.html.70b5fea0.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/category_zookeeper_index.html.ea8d8ff0.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/category_kafka_index.html.d21e5901.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/category_minio_index.html.909c2d43.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/category_index.html.99c05b96.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/timeline_index.html.411f6642.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/article_index.html.e22623f9.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/404.html.06ca67e5.js" as="script"><link rel="prefetch" href="/tech-blog/assets/js/tag_index.html.937bf476.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><div class="vp-theme-container external-link-icon"><!--[--><header class="vp-navbar"><div class="vp-toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a class="route-link" href="/tech-blog/"><img class="vp-site-logo" src="https://vuejs.press/images/hero.png" alt="架构师之路"><span class="vp-site-name vp-hide-mobile" aria-hidden="true">架构师之路</span></a></span><div class="vp-navbar-items-wrapper" style=""><!--[--><!--]--><nav class="vp-navbar-items vp-hide-mobile" aria-label="site navigation"><!--[--><div class="vp-navbar-item"><a class="route-link auto-link" href="/tech-blog/" aria-label="主页"><!---->主页<!----></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/tech-blog/article/" aria-label="文章"><!---->文章<!----></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/tech-blog/category/" aria-label="分类"><!---->分类<!----></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/tech-blog/tag/" aria-label="标签"><!---->标签<!----></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/tech-blog/timeline/" aria-label="时间线"><!---->时间线<!----></a></div><!--]--></nav><!--[--><!--]--><button class="vp-toggle-color-mode-button" title="toggle color mode"><svg class="light-icon" viewbox="0 0 32 32" style=""><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg class="dark-icon" viewbox="0 0 32 32" style="display:none;"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="vp-sidebar-mask"></div><!--[--><aside class="vp-sidebar"><nav class="vp-navbar-items" aria-label="site navigation"><!--[--><div class="vp-navbar-item"><a class="route-link auto-link" href="/tech-blog/" aria-label="主页"><!---->主页<!----></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/tech-blog/article/" aria-label="文章"><!---->文章<!----></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/tech-blog/category/" aria-label="分类"><!---->分类<!----></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/tech-blog/tag/" aria-label="标签"><!---->标签<!----></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/tech-blog/timeline/" aria-label="时间线"><!---->时间线<!----></a></div><!--]--></nav><!--[--><!--]--><ul class="vp-sidebar-items"><!--[--><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">Kafka 集群 Topic、消息大小、节点格式上限管控原理 <!----></p><!----></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="vp-page"><!--[--><!--]--><div class="theme-default-content"><!--[--><!--]--><div><h1 id="kafka-集群-topic、消息大小、节点格式上限管控原理" tabindex="-1"><a class="header-anchor" href="#kafka-集群-topic、消息大小、节点格式上限管控原理"><span>Kafka 集群 Topic、消息大小、节点格式上限管控原理</span></a></h1><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre class="language-text"><code><span class="line">kafka 集群对创建topic的数量有限制吗，发送的消息内容大小有限制吗，kafka集群节点的个数有限制吗，</span>
<span class="line">如何来合理的设置topic的分区数量和副本数量?</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>Kafka 集群在创建 Topic 的数量、发送的消息内容大小、集群节点的个数方面都有一定的限制和设计考量。 合理设置 Topic 的分区数量和副本数量对集群性能和可靠性至关重要。以下是详细的解释和建议。</p><h3 id="_1-kafka-集群对创建-topic-的数量限制" tabindex="-1"><a class="header-anchor" href="#_1-kafka-集群对创建-topic-的数量限制"><span>1. Kafka 集群对创建 Topic 的数量限制</span></a></h3><p>Kafka 本身对创建 Topic 的数量没有硬性限制，但实际中受限于以下因素：</p><ul><li><p><strong>ZooKeeper 资源限制</strong>：Kafka 的元数据（包括 Topic 和分区信息）存储在 ZooKeeper 中。大量 的 Topic 会增加 ZooKeeper 的负载。</p></li><li><p><strong>Broker 资源限制</strong>：每个 Broker 需要管理其上的分区和副本。大量的 Topic 会增加 Broker 的 管理负担，影响性能。</p></li></ul><h4 id="建议" tabindex="-1"><a class="header-anchor" href="#建议"><span>建议</span></a></h4><ul><li><strong>监控 ZooKeeper 负载</strong>：确保 ZooKeeper 的内存和 CPU 资源充足。</li><li><strong>均衡分布 Topic</strong>：合理分配 Topic 到不同的 Broker，避免单个 Broker 过载。</li></ul><h3 id="_2-kafka-发送的消息内容大小限制" tabindex="-1"><a class="header-anchor" href="#_2-kafka-发送的消息内容大小限制"><span>2. Kafka 发送的消息内容大小限制</span></a></h3><p>Kafka 对单条消息的最大大小有默认限制，可以通过配置调整：</p><ul><li><strong>默认最大消息大小</strong>：1 MB</li><li><strong>调整最大消息大小</strong>：可以通过配置参数 <code>message.max.bytes</code> 来调整。</li></ul><h4 id="配置示例" tabindex="-1"><a class="header-anchor" href="#配置示例"><span>配置示例</span></a></h4><div class="language-properties line-numbers-mode" data-highlighter="prismjs" data-ext="properties" data-title="properties"><pre class="language-properties"><code><span class="line"><span class="token comment"># server.properties</span></span>
<span class="line"><span class="token key attr-name">message.max.bytes</span><span class="token punctuation">=</span><span class="token value attr-value">10485760  # 将单条消息的最大大小设置为 10 MB</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-kafka-集群节点的个数限制" tabindex="-1"><a class="header-anchor" href="#_3-kafka-集群节点的个数限制"><span>3. Kafka 集群节点的个数限制</span></a></h3><p>Kafka 集群的节点数量没有硬性上限，但实践中受限于以下因素：</p><ul><li><strong>网络拓扑结构</strong>：大量节点可能会导致网络复杂性增加。</li><li><strong>协调开销</strong>：更多的节点意味着更多的协调开销，特别是在 Leader 选举和副本同步方面。</li></ul><h4 id="建议-1" tabindex="-1"><a class="header-anchor" href="#建议-1"><span>建议</span></a></h4><ul><li><strong>合理规划集群大小</strong>：根据业务需求和负载情况，合理规划集群的节点数量。</li><li><strong>分层管理</strong>：对大型集群，可以考虑分层管理，例如分为多个逻辑集群。</li></ul><h3 id="_4-设置-topic-的分区数量和副本数量" tabindex="-1"><a class="header-anchor" href="#_4-设置-topic-的分区数量和副本数量"><span>4. 设置 Topic 的分区数量和副本数量</span></a></h3><h4 id="分区数量的设置" tabindex="-1"><a class="header-anchor" href="#分区数量的设置"><span>分区数量的设置</span></a></h4><p>分区数量影响并行处理能力和负载均衡：</p><ul><li><strong>提高并行处理能力</strong>：更多的分区意味着更多的并行处理能力。</li><li><strong>均衡负载</strong>：分区数量应能均匀分布在所有 Broker 上。</li></ul><h4 id="设置分区数量的建议" tabindex="-1"><a class="header-anchor" href="#设置分区数量的建议"><span>设置分区数量的建议</span></a></h4><ul><li><strong>并行度</strong>：根据生产者和消费者的并行度设置分区数量。</li><li><strong>负载均衡</strong>：确保分区数量能均匀分布在所有 Broker 上。例如，有 3 个 Broker，可以设置分区数量 为 3 的倍数。</li></ul><h4 id="副本数量的设置" tabindex="-1"><a class="header-anchor" href="#副本数量的设置"><span>副本数量的设置</span></a></h4><p>副本数量影响数据的高可用性和容错能力：</p><ul><li><strong>提高容错能力</strong>：更多的副本意味着更高的容错能力。</li><li><strong>资源开销</strong>：更多的副本会增加存储和网络开销。</li></ul><h4 id="设置副本数量的建议" tabindex="-1"><a class="header-anchor" href="#设置副本数量的建议"><span>设置副本数量的建议</span></a></h4><ul><li><strong>高可用性</strong>：根据业务需求设置副本数量。一般来说，副本数量设置为 3 可以容忍 1 个节点故障。</li><li><strong>资源平衡</strong>：确保副本数量小于等于 Broker 数量。</li></ul><h3 id="核心代码和配置示例" tabindex="-1"><a class="header-anchor" href="#核心代码和配置示例"><span>核心代码和配置示例</span></a></h3><h4 id="创建-topic-并设置分区和副本" tabindex="-1"><a class="header-anchor" href="#创建-topic-并设置分区和副本"><span>创建 Topic 并设置分区和副本</span></a></h4><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="line">bin/kafka-topics.sh <span class="token parameter variable">--create</span> <span class="token parameter variable">--topic</span> my_topic --bootstrap-server localhost:9092 <span class="token parameter variable">--partitions</span> <span class="token number">6</span> --replication-factor <span class="token number">3</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h4 id="修改消息大小限制的配置" tabindex="-1"><a class="header-anchor" href="#修改消息大小限制的配置"><span>修改消息大小限制的配置</span></a></h4><div class="language-properties line-numbers-mode" data-highlighter="prismjs" data-ext="properties" data-title="properties"><pre class="language-properties"><code><span class="line"><span class="token comment"># server.properties</span></span>
<span class="line"><span class="token key attr-name">message.max.bytes</span><span class="token punctuation">=</span><span class="token value attr-value">10485760  # 将单条消息的最大大小设置为 10 MB</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_5-实际应用中的考虑" tabindex="-1"><a class="header-anchor" href="#_5-实际应用中的考虑"><span>5. 实际应用中的考虑</span></a></h3><h4 id="集群规模和性能" tabindex="-1"><a class="header-anchor" href="#集群规模和性能"><span>集群规模和性能</span></a></h4><ul><li><strong>小型集群</strong>：3-10 个节点，适用于中小型企业和应用。</li><li><strong>中型集群</strong>：10-50 个节点，适用于中大型企业和高负载应用。</li><li><strong>大型集群</strong>：50 个节点以上，适用于大型企业和互联网公司。</li></ul><h4 id="监控和维护" tabindex="-1"><a class="header-anchor" href="#监控和维护"><span>监控和维护</span></a></h4><ul><li><strong>监控工具</strong>：使用 Kafka 的监控工具和指标（如 Kafka Manager、Prometheus + Grafana）监控集群状态。</li><li><strong>维护策略</strong>：定期检查集群状态，优化配置，及时处理故障。</li></ul><h3 id="_6-实例分析" tabindex="-1"><a class="header-anchor" href="#_6-实例分析"><span>6. 实例分析</span></a></h3><p>假设有一个 Kafka 集群，有 6 个 Broker，需要创建一个名为 <code>example_topic</code> 的 Topic，预计每秒处理 10000 条消息，并希望在保证高可用性的同时实现高性能。</p><h4 id="配置建议" tabindex="-1"><a class="header-anchor" href="#配置建议"><span>配置建议</span></a></h4><ul><li><strong>分区数量</strong>：12（保证每个 Broker 至少管理 2 个分区，充分利用并行处理能力）。</li><li><strong>副本数量</strong>：3（保证数据的高可用性，可以容忍 1 个节点故障）。</li></ul><h4 id="创建-topic-的命令" tabindex="-1"><a class="header-anchor" href="#创建-topic-的命令"><span>创建 Topic 的命令</span></a></h4><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="line">bin/kafka-topics.sh <span class="token parameter variable">--create</span> <span class="token parameter variable">--topic</span> example_topic --bootstrap-server localhost:9092 </span>
<span class="line"><span class="token parameter variable">--partitions</span> <span class="token number">12</span> --replication-factor <span class="token number">3</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="配置文件中的示例" tabindex="-1"><a class="header-anchor" href="#配置文件中的示例"><span>配置文件中的示例</span></a></h4><div class="language-properties line-numbers-mode" data-highlighter="prismjs" data-ext="properties" data-title="properties"><pre class="language-properties"><code><span class="line"><span class="token comment"># server.properties</span></span>
<span class="line"><span class="token key attr-name">message.max.bytes</span><span class="token punctuation">=</span><span class="token value attr-value">10485760  # 将单条消息的最大大小设置为 10 MB</span></span>
<span class="line"><span class="token key attr-name">log.retention.hours</span><span class="token punctuation">=</span><span class="token value attr-value">168     # 日志保留时间设置为 7 天</span></span>
<span class="line"><span class="token key attr-name">num.partitions</span><span class="token punctuation">=</span><span class="token value attr-value">12           # 默认分区数量</span></span>
<span class="line"><span class="token key attr-name">default.replication.factor</span><span class="token punctuation">=</span><span class="token value attr-value">3 # 默认副本数量</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_7-总结" tabindex="-1"><a class="header-anchor" href="#_7-总结"><span>7. 总结</span></a></h3><ul><li><strong>Topic 数量</strong>：Kafka 对 Topic 数量没有硬性限制，但受限于 ZooKeeper 和 Broker 资源。</li><li><strong>消息大小</strong>：默认单条消息最大大小为 1 MB，可以通过配置调整。</li><li><strong>集群节点数量</strong>：没有硬性上限，但需要合理规划以避免网络和协调开销。</li><li><strong>分区数量</strong>：根据并行处理能力和负载均衡需求设置。</li><li><strong>副本数量</strong>：根据高可用性和容错需求设置。</li></ul><p>通过合理设置这些参数，可以优化 Kafka 集群的性能和可靠性，确保其在高并发和高负载情况下稳定运行。</p><h3 id="为什么数量设置为3" tabindex="-1"><a class="header-anchor" href="#为什么数量设置为3"><span>为什么数量设置为3？</span></a></h3><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre class="language-text"><code><span class="line">上述副本数量设置为3，如果一个节点故障，会从剩余两个节点选择一个为leader,假如剩余的leader故障，</span>
<span class="line">还有一个节点是否可以正常对外提供服务，如果剩余的folower节点故障，难道不是还有一个节点可以正常提</span>
<span class="line">供服务吗？</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>副本数量（replication factor）为 3 是一种常见的配置，但不是最小值。这个配置选择的原因在于它能 够在保证数据高可用性的同时提供容错能力。下面详细解释为什么副本数量为 3 可以容忍一个节点故障，以 及其他相关的配置选择。</p><h3 id="_1-副本数量-replication-factor-的最小值" tabindex="-1"><a class="header-anchor" href="#_1-副本数量-replication-factor-的最小值"><span>1. 副本数量（Replication Factor）的最小值</span></a></h3><p>Kafka 的副本数量最小可以设置为 1，但副本数量为 1 的情况下没有任何容错能力，因为数据只存在于一个 节点上。一旦这个节点发生故障，数据就无法访问。</p><h3 id="_2-副本数量为-3-的优势" tabindex="-1"><a class="header-anchor" href="#_2-副本数量为-3-的优势"><span>2. 副本数量为 3 的优势</span></a></h3><p>副本数量为 3 是一种权衡数据高可用性和资源开销的常见配置。它的主要优势包括：</p><ul><li><strong>容错能力</strong>：能够容忍最多一个节点故障。</li><li><strong>数据高可用性</strong>：即使一个节点故障，数据仍然可以通过其他两个节点访问。</li><li><strong>ISR 列表</strong>：ISR（In-Sync Replica）列表包含所有与 Leader 保持同步的副本，保证了数据的一致性。</li></ul><h3 id="_3-容忍节点故障的原理" tabindex="-1"><a class="header-anchor" href="#_3-容忍节点故障的原理"><span>3. 容忍节点故障的原理</span></a></h3><h4 id="副本数量为-3-时的容错能力" tabindex="-1"><a class="header-anchor" href="#副本数量为-3-时的容错能力"><span>副本数量为 3 时的容错能力</span></a></h4><p>假设一个分区有 3 个副本，分布在 3 个不同的节点上：</p><ul><li><strong>正常状态</strong>：3 个副本中，一个是 Leader，两个是 Follower。</li><li><strong>一个节点故障</strong>：假设 Leader 节点故障，Kafka 会从剩下的 2 个 Follower 副本中选举新的 Leader。</li></ul><p>这种配置可以容忍一个节点故障，因为剩余的 2 个副本能够保证数据的可用性和一致性。</p><h3 id="_4-副本数量与节点故障的关系" tabindex="-1"><a class="header-anchor" href="#_4-副本数量与节点故障的关系"><span>4. 副本数量与节点故障的关系</span></a></h3><h4 id="副本数量与容错能力的关系" tabindex="-1"><a class="header-anchor" href="#副本数量与容错能力的关系"><span>副本数量与容错能力的关系</span></a></h4><ul><li><strong>副本数量 1</strong>：无容错能力，节点故障即数据不可用。</li><li><strong>副本数量 2</strong>：能够容忍一个节点故障，但不推荐，因为这时仅剩一个副本，无法再提供副本冗余。</li><li><strong>副本数量 3</strong>：能够容忍一个节点故障，同时保持高可用性和数据冗余。</li><li><strong>副本数量 n</strong>：能够容忍 n-1 个节点故障，但资源开销较大，需要权衡。</li></ul><h3 id="_5-为什么副本数量为-3-可以容忍一个节点故障" tabindex="-1"><a class="header-anchor" href="#_5-为什么副本数量为-3-可以容忍一个节点故障"><span>5. 为什么副本数量为 3 可以容忍一个节点故障</span></a></h3><h4 id="数据同步和-isr-列表" tabindex="-1"><a class="header-anchor" href="#数据同步和-isr-列表"><span>数据同步和 ISR 列表</span></a></h4><p>Kafka 使用 ISR 列表管理同步状态。ISR 列表包含所有与 Leader 保持同步的副本。只有当消息被写入到所有 ISR 副本后，Leader 才确认消息提交。</p><h4 id="副本数量为-3-的情况下的-isr-列表" tabindex="-1"><a class="header-anchor" href="#副本数量为-3-的情况下的-isr-列表"><span>副本数量为 3 的情况下的 ISR 列表</span></a></h4><ul><li><strong>正常状态</strong>：3 个副本（1 个 Leader + 2 个 Follower）都在 ISR 列表中。</li><li><strong>一个节点故障</strong>：假设 Leader 节点故障，Kafka 会从 ISR 列表中的 2 个 Follower 副本中选举新的 Leader。</li></ul><p>这种情况下，即使一个节点故障，剩余的 2 个副本仍在 ISR 列表中，能够保证数据一致性和高可用性。</p><h3 id="_6-核心代码示例" tabindex="-1"><a class="header-anchor" href="#_6-核心代码示例"><span>6. 核心代码示例</span></a></h3><p>以下是管理 ISR 列表的核心代码示例：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token comment">// Partition.scala</span></span>
<span class="line"><span class="token keyword">class</span> <span class="token class-name">Partition</span><span class="token punctuation">(</span>val topicPartition<span class="token operator">:</span> <span class="token class-name">TopicPartition</span><span class="token punctuation">,</span> val leader<span class="token operator">:</span> <span class="token class-name">Int</span><span class="token punctuation">,</span> val replicas<span class="token operator">:</span> <span class="token class-name">List</span><span class="token punctuation">[</span><span class="token class-name">Int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    val isr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicReference</span><span class="token punctuation">[</span><span class="token class-name">List</span><span class="token punctuation">[</span><span class="token class-name">Int</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">(</span>replicas<span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line">    def <span class="token function">addToIsr</span><span class="token punctuation">(</span>replicaId<span class="token operator">:</span> <span class="token class-name">Int</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token class-name">Unit</span> <span class="token operator">=</span> <span class="token punctuation">{</span></span>
<span class="line">        val currentIsr <span class="token operator">=</span> isr<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>currentIsr<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>replicaId<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">            isr<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>replicaId <span class="token operator">::</span> <span class="token function">currentIsr</span><span class="token punctuation">)</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    def <span class="token function">removeFromIsr</span><span class="token punctuation">(</span>replicaId<span class="token operator">:</span> <span class="token class-name">Int</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token class-name">Unit</span> <span class="token operator">=</span> <span class="token punctuation">{</span></span>
<span class="line">        val currentIsr <span class="token operator">=</span> isr<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">        <span class="token keyword">if</span> <span class="token punctuation">(</span>currentIsr<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>replicaId<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">            isr<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>currentIsr<span class="token punctuation">.</span><span class="token function">filterNot</span><span class="token punctuation">(</span>_ <span class="token operator">==</span> replicaId<span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    def <span class="token function">isInSync</span><span class="token punctuation">(</span>replicaId<span class="token operator">:</span> <span class="token class-name">Int</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token class-name">Boolean</span> <span class="token operator">=</span> <span class="token punctuation">{</span></span>
<span class="line">        isr<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>replicaId<span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_7-副本数量的配置建议" tabindex="-1"><a class="header-anchor" href="#_7-副本数量的配置建议"><span>7. 副本数量的配置建议</span></a></h3><ul><li><strong>最小副本数量</strong>：根据业务需求和资源情况，最小副本数量通常为 3，以保证高可用性和容错能力。</li><li><strong>资源和性能权衡</strong>：副本数量越多，资源开销越大，设置时需要权衡性能和资源利用。</li></ul><h3 id="_8-配置示例" tabindex="-1"><a class="header-anchor" href="#_8-配置示例"><span>8. 配置示例</span></a></h3><p>创建一个副本数量为 3 的 Topic：</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="line">bin/kafka-topics.sh <span class="token parameter variable">--create</span> <span class="token parameter variable">--topic</span> my_topic --bootstrap-server localhost:9092 <span class="token parameter variable">--partitions</span> <span class="token number">6</span> --replication-factor <span class="token number">3</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h3><ul><li><strong>副本数量为 3 的优势</strong>：能够在保证数据高可用性的同时提供容错能力，是一种常见的配置选择。</li><li><strong>容错能力原理</strong>：副本数量为 3 时，能够容忍一个节点故障，同时保持数据的一致性和高可用性。</li><li><strong>配置建议</strong>：根据业务需求和资源情况，合理设置副本数量，通常建议为 3，以确保高可用性和容错能力。</li></ul><p>通过这些配置和机制，Kafka 能够在高并发和高负载的情况下，提供高性能、高可用性和高可靠性的消息服务。</p></div><!--[--><!--]--></div><footer class="vp-page-meta"><!----><div class="vp-meta-item git-info"><div class="vp-meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><div class="vp-meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: 939943844@qq.com">asus</span><!----><!--]--><!--]--></span></div></div></footer><!----><!--[--><!--]--></main><!--]--></div><!--[--><!----><!--]--><!--]--></div>
    <script src="/tech-blog/assets/js/runtime~app.d2151947.js" defer></script><script src="/tech-blog/assets/js/6484.f9c8e027.js" defer></script><script src="/tech-blog/assets/js/app.92b4cbb5.js" defer></script>
  </body>
</html>
