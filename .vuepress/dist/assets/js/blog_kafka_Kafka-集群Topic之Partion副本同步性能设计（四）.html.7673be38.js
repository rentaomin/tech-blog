"use strict";(self.webpackChunkarch_guide=self.webpackChunkarch_guide||[]).push([[3603],{6237:(n,a,s)=>{s.r(a),s.d(a,{comp:()=>l,data:()=>c});var e=s(641);const p=[(0,e.Fv)('<h1 id="kafka-集群-topic-之-partion-副本同步性能设计-四" tabindex="-1"><a class="header-anchor" href="#kafka-集群-topic-之-partion-副本同步性能设计-四"><span>kafka 集群 Topic 之 Partion 副本同步性能设计（四）</span></a></h1><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre class="language-text"><code><span class="line">partition如何将文件分为多段文件，集群leader负责处理读写请求，那是否为性能瓶颈点，follower复制</span>\n<span class="line">同步leader数据，如果数据过大如何处理的，是如何控制不影响正常业务的情况下进行同步的，leader如何</span>\n<span class="line">确认follower数据已经同步完成</span>\n<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Kafka 的 Partition 通过日志分段（Log Segment）将文件分为多个段文件，以便于管理和清理日志，同时 提高查询效率。Kafka 的设计考虑了高可用性和性能，以避免单点性能瓶颈和数据同步过程中对正常业务的影响。 以下是详细说明：</p><h3 id="_1-partition-的日志分段设计" tabindex="-1"><a class="header-anchor" href="#_1-partition-的日志分段设计"><span>1. Partition 的日志分段设计</span></a></h3><h4 id="日志分段原理" tabindex="-1"><a class="header-anchor" href="#日志分段原理"><span>日志分段原理</span></a></h4><p>Kafka 将每个 Partition 的消息存储在多个日志分段中，每个日志分段是一个独立的文件。日志分段的好处包括：</p><ul><li><strong>易于管理</strong>：可以方便地进行日志清理和压缩。</li><li><strong>提高查询效率</strong>：通过分段索引可以快速定位消息。</li></ul><h4 id="核心代码示例" tabindex="-1"><a class="header-anchor" href="#核心代码示例"><span>核心代码示例</span></a></h4><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token comment">// LogSegment.scala</span></span>\n<span class="line"><span class="token keyword">class</span> <span class="token class-name">LogSegment</span><span class="token punctuation">(</span>val baseOffset<span class="token operator">:</span> <span class="token class-name">Long</span><span class="token punctuation">,</span> val log<span class="token operator">:</span> <span class="token class-name">File</span><span class="token punctuation">,</span> val index<span class="token operator">:</span> <span class="token class-name">File</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>\n<span class="line">    val logFile <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileChannel</span><span class="token punctuation">(</span>log<span class="token punctuation">)</span></span>\n<span class="line">    val indexFile <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IndexChannel</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span></span>\n<span class="line"></span>\n<span class="line">    def <span class="token function">append</span><span class="token punctuation">(</span>record<span class="token operator">:</span> <span class="token class-name">Record</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token class-name">Unit</span> <span class="token operator">=</span> <span class="token punctuation">{</span></span>\n<span class="line">        logFile<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>record<span class="token punctuation">)</span></span>\n<span class="line">        indexFile<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>record<span class="token punctuation">.</span>offset<span class="token punctuation">,</span> logFile<span class="token punctuation">.</span>position<span class="token punctuation">)</span></span>\n<span class="line">    <span class="token punctuation">}</span></span>\n<span class="line"></span>\n<span class="line">    def <span class="token function">read</span><span class="token punctuation">(</span>offset<span class="token operator">:</span> <span class="token class-name">Long</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token class-name">Record</span> <span class="token operator">=</span> <span class="token punctuation">{</span></span>\n<span class="line">        val indexEntry <span class="token operator">=</span> indexFile<span class="token punctuation">.</span><span class="token function">lookup</span><span class="token punctuation">(</span>offset<span class="token punctuation">)</span></span>\n<span class="line">        logFile<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>indexEntry<span class="token punctuation">.</span>position<span class="token punctuation">)</span></span>\n<span class="line">    <span class="token punctuation">}</span></span>\n<span class="line"><span class="token punctuation">}</span></span>\n<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-leader-和-follower-的读写和同步机制" tabindex="-1"><a class="header-anchor" href="#_2-leader-和-follower-的读写和同步机制"><span>2. Leader 和 Follower 的读写和同步机制</span></a></h3><h4 id="leader-负责读写请求" tabindex="-1"><a class="header-anchor" href="#leader-负责读写请求"><span>Leader 负责读写请求</span></a></h4><p>在 Kafka 中，每个 Partition 有一个 Leader 副本，负责处理所有的读写请求。这是设计上的性能瓶颈， 但 Kafka 通过以下方式缓解了这种瓶颈：</p><ul><li><strong>分区</strong>：将 Topic 分成多个 Partition，每个 Partition 有自己的 Leader，从而分摊读写负载。</li><li><strong>并行处理</strong>：生产者和消费者可以并行地向不同的 Partition 写入和读取数据。</li></ul><h4 id="follower-复制和同步数据" tabindex="-1"><a class="header-anchor" href="#follower-复制和同步数据"><span>Follower 复制和同步数据</span></a></h4><p>Follower 副本从 Leader 复制数据，以确保数据的一致性和高可用性。</p><h4 id="控制同步影响" tabindex="-1"><a class="header-anchor" href="#控制同步影响"><span>控制同步影响</span></a></h4><ul><li><strong>批量复制</strong>：Follower 从 Leader 批量拉取消息，减少网络开销。</li><li><strong>后台复制</strong>：复制过程在后台进行，不影响正常的读写请求。</li><li><strong>流控机制</strong>：Kafka 使用流控机制，确保复制过程中不会占用过多资源，影响正常业务。</li></ul><h4 id="核心代码示例-1" tabindex="-1"><a class="header-anchor" href="#核心代码示例-1"><span>核心代码示例</span></a></h4><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token comment">// ReplicaFetcherThread.scala</span></span>\n<span class="line"><span class="token keyword">class</span> <span class="token class-name">ReplicaFetcherThread</span><span class="token punctuation">(</span>replicaId<span class="token operator">:</span> <span class="token class-name">Int</span><span class="token punctuation">,</span> leaderId<span class="token operator">:</span> <span class="token class-name">Int</span><span class="token punctuation">,</span> partition<span class="token operator">:</span> <span class="token class-name">TopicPartition</span><span class="token punctuation">)</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractFetcherThread</span><span class="token punctuation">(</span>replicaId<span class="token punctuation">,</span> leaderId<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>\n<span class="line">    override def <span class="token function">fetch</span><span class="token punctuation">(</span>fetchRequest<span class="token operator">:</span> <span class="token class-name">FetchRequest<span class="token punctuation">.</span>Builder</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token class-name">Map</span><span class="token punctuation">[</span><span class="token class-name">TopicPartition</span><span class="token punctuation">,</span> <span class="token class-name">FetchDataInfo</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span></span>\n<span class="line">        val fetchResponse <span class="token operator">=</span> leaderBroker<span class="token punctuation">.</span><span class="token function">fetch</span><span class="token punctuation">(</span>fetchRequest<span class="token punctuation">)</span></span>\n<span class="line">        fetchResponse<span class="token punctuation">.</span>data<span class="token punctuation">.</span>asScala<span class="token punctuation">.</span>map <span class="token punctuation">{</span> <span class="token keyword">case</span> <span class="token punctuation">(</span>tp<span class="token punctuation">,</span> data<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span></span>\n<span class="line">            partition<span class="token punctuation">.</span>log<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span></span>\n<span class="line">            tp <span class="token operator">-&gt;</span> <span class="token class-name">FetchDataInfo</span><span class="token punctuation">(</span>partition<span class="token punctuation">.</span>log<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span>baseOffset<span class="token punctuation">,</span> data<span class="token punctuation">.</span>records<span class="token punctuation">.</span>sizeInBytes<span class="token punctuation">)</span><span class="token punctuation">)</span></span>\n<span class="line">        <span class="token punctuation">}</span><span class="token punctuation">.</span>toMap</span>\n<span class="line">    <span class="token punctuation">}</span></span>\n<span class="line"><span class="token punctuation">}</span></span>\n<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-控制同步过程中不影响正常业务" tabindex="-1"><a class="header-anchor" href="#_3-控制同步过程中不影响正常业务"><span>3. 控制同步过程中不影响正常业务</span></a></h3><h4 id="批量处理和异步复制" tabindex="-1"><a class="header-anchor" href="#批量处理和异步复制"><span>批量处理和异步复制</span></a></h4><ul><li><strong>批量处理</strong>：Follower 批量拉取消息，减少频繁的网络请求。</li><li><strong>异步复制</strong>：复制过程是异步的，不会阻塞正常的读写操作。</li></ul><h4 id="流控和速率限制" tabindex="-1"><a class="header-anchor" href="#流控和速率限制"><span>流控和速率限制</span></a></h4><p>Kafka 使用流控和速率限制机制，确保复制过程不会占用过多资源。可以通过配置参数调整复制的速率和资源占用。</p><h4 id="代码示例-流控和速率限制" tabindex="-1"><a class="header-anchor" href="#代码示例-流控和速率限制"><span>代码示例：流控和速率限制</span></a></h4><div class="language-properties line-numbers-mode" data-highlighter="prismjs" data-ext="properties" data-title="properties"><pre class="language-properties"><code><span class="line"><span class="token comment"># 配置参数示例</span></span>\n<span class="line"><span class="token key attr-name">replica.fetch.max.bytes</span><span class="token punctuation">=</span><span class="token value attr-value">1048576   # 每次拉取的最大字节数</span></span>\n<span class="line"><span class="token key attr-name">replica.fetch.wait.max.ms</span><span class="token punctuation">=</span><span class="token value attr-value">500     # 等待 Leader 响应的最大时间</span></span>\n<span class="line"><span class="token key attr-name">num.replica.fetchers</span><span class="token punctuation">=</span><span class="token value attr-value">3            # 每个 Follower 用于复制的线程数</span></span>\n<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_4-leader-确认-follower-数据同步完成" tabindex="-1"><a class="header-anchor" href="#_4-leader-确认-follower-数据同步完成"><span>4. Leader 确认 Follower 数据同步完成</span></a></h3><h4 id="isr-列表-in-sync-replica" tabindex="-1"><a class="header-anchor" href="#isr-列表-in-sync-replica"><span>ISR 列表（In-Sync Replica）</span></a></h4><p>ISR 列表包含所有与 Leader 保持同步的副本。只有在消息被写入到 ISR 列表中的所有副本后，才认为消息被成功提交。</p><h4 id="核心代码示例-2" tabindex="-1"><a class="header-anchor" href="#核心代码示例-2"><span>核心代码示例</span></a></h4><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token comment">// Partition.scala</span></span>\n<span class="line"><span class="token keyword">class</span> <span class="token class-name">Partition</span><span class="token punctuation">(</span>val topicPartition<span class="token operator">:</span> <span class="token class-name">TopicPartition</span><span class="token punctuation">,</span> val leader<span class="token operator">:</span> <span class="token class-name">Int</span><span class="token punctuation">,</span> val replicas<span class="token operator">:</span> <span class="token class-name">List</span><span class="token punctuation">[</span><span class="token class-name">Int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>\n<span class="line">    val isr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicReference</span><span class="token punctuation">[</span><span class="token class-name">List</span><span class="token punctuation">[</span><span class="token class-name">Int</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">(</span>replicas<span class="token punctuation">)</span></span>\n<span class="line">    </span>\n<span class="line">    def <span class="token function">addToIsr</span><span class="token punctuation">(</span>replicaId<span class="token operator">:</span> <span class="token class-name">Int</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token class-name">Unit</span> <span class="token operator">=</span> <span class="token punctuation">{</span></span>\n<span class="line">        val currentIsr <span class="token operator">=</span> isr<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>\n<span class="line">        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>currentIsr<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>replicaId<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>\n<span class="line">            isr<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>replicaId <span class="token operator">::</span> <span class="token function">currentIsr</span><span class="token punctuation">)</span></span>\n<span class="line">        <span class="token punctuation">}</span></span>\n<span class="line">    <span class="token punctuation">}</span></span>\n<span class="line"></span>\n<span class="line">    def <span class="token function">removeFromIsr</span><span class="token punctuation">(</span>replicaId<span class="token operator">:</span> <span class="token class-name">Int</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token class-name">Unit</span> <span class="token operator">=</span> <span class="token punctuation">{</span></span>\n<span class="line">        val currentIsr <span class="token operator">=</span> isr<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>\n<span class="line">        <span class="token keyword">if</span> <span class="token punctuation">(</span>currentIsr<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>replicaId<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>\n<span class="line">            isr<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>currentIsr<span class="token punctuation">.</span><span class="token function">filterNot</span><span class="token punctuation">(</span>_ <span class="token operator">==</span> replicaId<span class="token punctuation">)</span><span class="token punctuation">)</span></span>\n<span class="line">        <span class="token punctuation">}</span></span>\n<span class="line">    <span class="token punctuation">}</span></span>\n<span class="line"></span>\n<span class="line">    def <span class="token function">isInSync</span><span class="token punctuation">(</span>replicaId<span class="token operator">:</span> <span class="token class-name">Int</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token class-name">Boolean</span> <span class="token operator">=</span> <span class="token punctuation">{</span></span>\n<span class="line">        isr<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>replicaId<span class="token punctuation">)</span></span>\n<span class="line">    <span class="token punctuation">}</span></span>\n<span class="line"><span class="token punctuation">}</span></span>\n<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h3><ol><li><strong>Partition 的日志分段设计</strong>：每个 Partition 由多个日志分段组成，分段存储便于管理和提高查询效率。</li><li><strong>Leader 负责读写请求</strong>：虽然是性能瓶颈点，但通过分区和并行处理缓解了瓶颈。</li><li><strong>Follower 复制和同步数据</strong>：通过批量处理、异步复制和流控机制，确保同步过程中不影响正常业务。</li><li><strong>确认同步完成</strong>：使用 ISR 列表确保副本同步，当消息写入到所有 ISR 副本后，才认为消息被成功提交。</li></ol><p>通过这些设计，Kafka 实现了高效的消息存储和处理机制，确保了消息的高可用性、有序性和一致性。</p>',34)],t={},l=(0,s(6262).A)(t,[["render",function(n,a){return(0,e.uX)(),(0,e.CE)("div",null,p)}]]),c=JSON.parse('{"path":"/blog/kafka/Kafka-%E9%9B%86%E7%BE%A4Topic%E4%B9%8BPartion%E5%89%AF%E6%9C%AC%E5%90%8C%E6%AD%A5%E6%80%A7%E8%83%BD%E8%AE%BE%E8%AE%A1%EF%BC%88%E5%9B%9B%EF%BC%89.html","title":"kafka 集群 Topic 之 Partion 副本同步性能设计（四）","lang":"zh-CN","frontmatter":{"date":"2021-07-07T00:00:00.000Z","category":["Kafka"],"tag":["消息队列"],"sticky":true,"excerpt":"<p>Kafka 集群原理设计分析</p>"},"headers":[{"level":3,"title":"1. Partition 的日志分段设计","slug":"_1-partition-的日志分段设计","link":"#_1-partition-的日志分段设计","children":[]},{"level":3,"title":"2. Leader 和 Follower 的读写和同步机制","slug":"_2-leader-和-follower-的读写和同步机制","link":"#_2-leader-和-follower-的读写和同步机制","children":[]},{"level":3,"title":"3. 控制同步过程中不影响正常业务","slug":"_3-控制同步过程中不影响正常业务","link":"#_3-控制同步过程中不影响正常业务","children":[]},{"level":3,"title":"4. Leader 确认 Follower 数据同步完成","slug":"_4-leader-确认-follower-数据同步完成","link":"#_4-leader-确认-follower-数据同步完成","children":[]},{"level":3,"title":"总结","slug":"总结","link":"#总结","children":[]}],"git":{"updatedTime":1720877624000,"contributors":[{"name":"asus","email":"939943844@qq.com","commits":1}]},"filePathRelative":"blog/kafka/Kafka-集群Topic之Partion副本同步性能设计（四）.md"}')}}]);