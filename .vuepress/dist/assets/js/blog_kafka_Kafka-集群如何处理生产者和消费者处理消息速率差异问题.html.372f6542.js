"use strict";(self.webpackChunkarch_guide=self.webpackChunkarch_guide||[]).push([[5334],{8034:(n,a,s)=>{s.r(a),s.d(a,{comp:()=>l,data:()=>o});var p=s(641);const e=[(0,p.Fv)('<h1 id="kafka-集群如何处理生产者和消费者处理消息速率差异问题" tabindex="-1"><a class="header-anchor" href="#kafka-集群如何处理生产者和消费者处理消息速率差异问题"><span>kafka 集群如何处理生产者和消费者处理消息速率差异问题?</span></a></h1><p>Kafka 集群通过多种机制来处理生产者和消费者处理消息速率的差异问题，确保消息的高效传递和系统的 稳定性。以下是详细的解释和机制：</p><h3 id="_1-消息缓冲机制" tabindex="-1"><a class="header-anchor" href="#_1-消息缓冲机制"><span>1. 消息缓冲机制</span></a></h3><p>Kafka 使用消息缓冲机制来处理生产者和消费者速率的不匹配。</p><h4 id="内部机制" tabindex="-1"><a class="header-anchor" href="#内部机制"><span>内部机制</span></a></h4><ul><li><strong>生产者端缓冲</strong>：生产者在发送消息之前，将消息放入一个缓冲区（<code>buffer.memory</code>），然后批量发送。这不仅 提高了写入效率，也缓解了瞬时高峰压力。</li><li><strong>Broker 端缓冲</strong>：Broker 将消息存储在日志中，消费者可以根据自己的速率从日志中拉取消息。</li></ul><h4 id="配置示例" tabindex="-1"><a class="header-anchor" href="#配置示例"><span>配置示例</span></a></h4><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token class-name">Properties</span> props <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>\n<span class="line">props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;buffer.memory&quot;</span><span class="token punctuation">,</span> <span class="token number">33554432</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 生产者缓冲区大小，默认32MB</span></span>\n<span class="line">props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;batch.size&quot;</span><span class="token punctuation">,</span> <span class="token number">16384</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 批量发送的大小，默认16KB</span></span>\n<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-消费者的拉取模型-pull-model" tabindex="-1"><a class="header-anchor" href="#_2-消费者的拉取模型-pull-model"><span>2. 消费者的拉取模型（Pull Model）</span></a></h3><p>Kafka 使用拉取模型（pull model）而不是推送模型（push model），允许消费者根据自身的处理能力来拉取消息。这种设计有效 地避免了消息积压和处理过载的问题。</p><h4 id="配置示例-1" tabindex="-1"><a class="header-anchor" href="#配置示例-1"><span>配置示例</span></a></h4><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token comment">// 消费者拉取消息的配置</span></span>\n<span class="line"><span class="token class-name">Properties</span> props <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>\n<span class="line">props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;max.poll.records&quot;</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 每次拉取的最大记录数</span></span>\n<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-消费者组和负载均衡" tabindex="-1"><a class="header-anchor" href="#_3-消费者组和负载均衡"><span>3. 消费者组和负载均衡</span></a></h3><p>通过消费者组，Kafka 可以将分区分配给多个消费者，实现负载均衡。每个消费者组中的消费者负责不同的分区，从而提高整体的消费 能力。</p><h4 id="工作机制" tabindex="-1"><a class="header-anchor" href="#工作机制"><span>工作机制</span></a></h4><ul><li><strong>分区分配策略</strong>：Kafka 提供多种分区分配策略（如 range、roundrobin）来平衡负载。</li><li><strong>再平衡</strong>：当消费者组的成员发生变化时，Kafka 会自动触发再平衡（rebalance），重新分配分区给消费者。</li></ul><h4 id="配置示例-2" tabindex="-1"><a class="header-anchor" href="#配置示例-2"><span>配置示例</span></a></h4><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token class-name">Properties</span> props <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>\n<span class="line">props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;group.id&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;consumer-group-1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 消费者组ID</span></span>\n<span class="line"><span class="token comment">// 分区分配策略</span></span>\n<span class="line">props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;partition.assignment.strategy&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;org.apache.kafka.clients.consumer.RangeAssignor&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </span>\n<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_4-消息积压处理" tabindex="-1"><a class="header-anchor" href="#_4-消息积压处理"><span>4. 消息积压处理</span></a></h3><p>在消费者处理速度远低于生产者的情况下，消息可能会在 Kafka 中积压。Kafka 提供了一些机制来处理消息积压。</p><h4 id="调整保留策略" tabindex="-1"><a class="header-anchor" href="#调整保留策略"><span>调整保留策略</span></a></h4><p>通过调整消息保留策略，Kafka 可以在一定时间内保留消息，以确保消费者有足够的时间处理积压的消息。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token comment">// 调整消息保留时间和日志大小</span></span>\n<span class="line"><span class="token class-name">Properties</span> props <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>\n<span class="line">props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;log.retention.hours&quot;</span><span class="token punctuation">,</span> <span class="token number">168</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 消息保留时间，默认7天</span></span>\n<span class="line">props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;log.retention.bytes&quot;</span><span class="token punctuation">,</span> <span class="token number">1073741824</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 每个分区日志大小，默认1GB</span></span>\n<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="扩展消费者组" tabindex="-1"><a class="header-anchor" href="#扩展消费者组"><span>扩展消费者组</span></a></h4><p>通过增加消费者组的消费者数量，可以提高消息处理能力，从而减少消息积压。</p><h3 id="_5-动态调整机制" tabindex="-1"><a class="header-anchor" href="#_5-动态调整机制"><span>5. 动态调整机制</span></a></h3><p>Kafka 提供了一些配置和机制，可以动态调整生产者和消费者的参数，以应对速率差异问题。</p><h4 id="动态调整生产者速率" tabindex="-1"><a class="header-anchor" href="#动态调整生产者速率"><span>动态调整生产者速率</span></a></h4><p>通过调整生产者端的重试机制和限速配置，可以控制生产者发送消息的速率，避免过快发送导致的积压。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token class-name">Properties</span> props <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>\n<span class="line">props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;retries&quot;</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 生产者重试次数</span></span>\n<span class="line">props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;linger.ms&quot;</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// 等待时间，聚合更多消息进行批量发送</span></span>\n<span class="line">props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;max.in.flight.requests.per.connection&quot;</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 每个连接最大未确认请求数</span></span>\n<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="动态调整消费者速率" tabindex="-1"><a class="header-anchor" href="#动态调整消费者速率"><span>动态调整消费者速率</span></a></h4><p>通过调整消费者端的轮询间隔和每次拉取的消息数量，可以控制消费者的处理速率，适应不同的消费能力。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token class-name">Properties</span> props <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>\n<span class="line">props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;fetch.min.bytes&quot;</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 每次拉取的最小数据量</span></span>\n<span class="line">props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;fetch.max.wait.ms&quot;</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 拉取消息的最大等待时间</span></span>\n<span class="line">props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;max.poll.interval.ms&quot;</span><span class="token punctuation">,</span> <span class="token number">300000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 消费者处理消息的最大时间间隔</span></span>\n<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_6-消费者健康监控和自动扩展" tabindex="-1"><a class="header-anchor" href="#_6-消费者健康监控和自动扩展"><span>6. 消费者健康监控和自动扩展</span></a></h3><p>通过监控消费者的健康状态和消费速率，可以及时发现消费能力不足的问题，并自动扩展消费者实例以提高处理能力。</p><h4 id="监控工具" tabindex="-1"><a class="header-anchor" href="#监控工具"><span>监控工具</span></a></h4><p>使用 Kafka 的监控工具（如 Kafka Manager、Prometheus + Grafana）可以实时监控消费者的处理速率和积压情况， 及时进行扩展和调整。</p><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h3><p>Kafka 通过多种机制有效处理生产者和消费者处理速率的差异问题，确保系统的高效和稳定运行。这些机制包括：</p><ul><li><strong>消息缓冲机制</strong>：在生产者和 Broker 端使用缓冲区来缓解速率差异。</li><li><strong>消费者的拉取模型</strong>：允许消费者根据自身处理能力拉取消息，避免过载。</li><li><strong>消费者组和负载均衡</strong>：通过分区分配和再平衡提高消费能力。</li><li><strong>消息积压处理</strong>：调整消息保留策略和扩展消费者组来处理积压。</li><li><strong>动态调整机制</strong>：通过动态调整生产者和消费者的参数，适应不同的处理速率。</li><li><strong>消费者健康监控和自动扩展</strong>：监控消费者状态，自动扩展实例提高处理能力。</li></ul><p>通过这些设计和优化，Kafka 能够在高并发和高负载的环境中保持高效的消息传递和处理能力。</p>',41)],t={},l=(0,s(6262).A)(t,[["render",function(n,a){return(0,p.uX)(),(0,p.CE)("div",null,e)}]]),o=JSON.parse('{"path":"/blog/kafka/Kafka-%E9%9B%86%E7%BE%A4%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85%E5%A4%84%E7%90%86%E6%B6%88%E6%81%AF%E9%80%9F%E7%8E%87%E5%B7%AE%E5%BC%82%E9%97%AE%E9%A2%98.html","title":"kafka 集群如何处理生产者和消费者处理消息速率差异问题?","lang":"zh-CN","frontmatter":{"date":"2021-07-07T00:00:00.000Z","category":["Kafka"],"tag":["消息队列"],"sticky":true,"excerpt":"<p>Kafka 集群原理设计分析</p>"},"headers":[{"level":3,"title":"1. 消息缓冲机制","slug":"_1-消息缓冲机制","link":"#_1-消息缓冲机制","children":[]},{"level":3,"title":"2. 消费者的拉取模型（Pull Model）","slug":"_2-消费者的拉取模型-pull-model","link":"#_2-消费者的拉取模型-pull-model","children":[]},{"level":3,"title":"3. 消费者组和负载均衡","slug":"_3-消费者组和负载均衡","link":"#_3-消费者组和负载均衡","children":[]},{"level":3,"title":"4. 消息积压处理","slug":"_4-消息积压处理","link":"#_4-消息积压处理","children":[]},{"level":3,"title":"5. 动态调整机制","slug":"_5-动态调整机制","link":"#_5-动态调整机制","children":[]},{"level":3,"title":"6. 消费者健康监控和自动扩展","slug":"_6-消费者健康监控和自动扩展","link":"#_6-消费者健康监控和自动扩展","children":[]},{"level":3,"title":"总结","slug":"总结","link":"#总结","children":[]}],"git":{"updatedTime":1720536662000,"contributors":[{"name":"asus","email":"939943844@qq.com","commits":1}]},"filePathRelative":"blog/kafka/Kafka-集群如何处理生产者和消费者处理消息速率差异问题.md"}')}}]);