"use strict";(self.webpackChunkarch_guide=self.webpackChunkarch_guide||[]).push([[5500],{586:(a,s,n)=>{n.r(s),n.d(s,{comp:()=>p,data:()=>i});var e=n(641);const l=[(0,e.Fv)('<h1 id="kafka-集群-topic、消息大小、节点格式上限管控原理" tabindex="-1"><a class="header-anchor" href="#kafka-集群-topic、消息大小、节点格式上限管控原理"><span>Kafka 集群 Topic、消息大小、节点格式上限管控原理</span></a></h1><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre class="language-text"><code><span class="line">kafka 集群对创建topic的数量有限制吗，发送的消息内容大小有限制吗，kafka集群节点的个数有限制吗，</span>\n<span class="line">如何来合理的设置topic的分区数量和副本数量?</span>\n<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>Kafka 集群在创建 Topic 的数量、发送的消息内容大小、集群节点的个数方面都有一定的限制和设计考量。 合理设置 Topic 的分区数量和副本数量对集群性能和可靠性至关重要。以下是详细的解释和建议。</p><h3 id="_1-kafka-集群对创建-topic-的数量限制" tabindex="-1"><a class="header-anchor" href="#_1-kafka-集群对创建-topic-的数量限制"><span>1. Kafka 集群对创建 Topic 的数量限制</span></a></h3><p>Kafka 本身对创建 Topic 的数量没有硬性限制，但实际中受限于以下因素：</p><ul><li><p><strong>ZooKeeper 资源限制</strong>：Kafka 的元数据（包括 Topic 和分区信息）存储在 ZooKeeper 中。大量 的 Topic 会增加 ZooKeeper 的负载。</p></li><li><p><strong>Broker 资源限制</strong>：每个 Broker 需要管理其上的分区和副本。大量的 Topic 会增加 Broker 的 管理负担，影响性能。</p></li></ul><h4 id="建议" tabindex="-1"><a class="header-anchor" href="#建议"><span>建议</span></a></h4><ul><li><strong>监控 ZooKeeper 负载</strong>：确保 ZooKeeper 的内存和 CPU 资源充足。</li><li><strong>均衡分布 Topic</strong>：合理分配 Topic 到不同的 Broker，避免单个 Broker 过载。</li></ul><h3 id="_2-kafka-发送的消息内容大小限制" tabindex="-1"><a class="header-anchor" href="#_2-kafka-发送的消息内容大小限制"><span>2. Kafka 发送的消息内容大小限制</span></a></h3><p>Kafka 对单条消息的最大大小有默认限制，可以通过配置调整：</p><ul><li><strong>默认最大消息大小</strong>：1 MB</li><li><strong>调整最大消息大小</strong>：可以通过配置参数 <code>message.max.bytes</code> 来调整。</li></ul><h4 id="配置示例" tabindex="-1"><a class="header-anchor" href="#配置示例"><span>配置示例</span></a></h4><div class="language-properties line-numbers-mode" data-highlighter="prismjs" data-ext="properties" data-title="properties"><pre class="language-properties"><code><span class="line"><span class="token comment"># server.properties</span></span>\n<span class="line"><span class="token key attr-name">message.max.bytes</span><span class="token punctuation">=</span><span class="token value attr-value">10485760  # 将单条消息的最大大小设置为 10 MB</span></span>\n<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-kafka-集群节点的个数限制" tabindex="-1"><a class="header-anchor" href="#_3-kafka-集群节点的个数限制"><span>3. Kafka 集群节点的个数限制</span></a></h3><p>Kafka 集群的节点数量没有硬性上限，但实践中受限于以下因素：</p><ul><li><strong>网络拓扑结构</strong>：大量节点可能会导致网络复杂性增加。</li><li><strong>协调开销</strong>：更多的节点意味着更多的协调开销，特别是在 Leader 选举和副本同步方面。</li></ul><h4 id="建议-1" tabindex="-1"><a class="header-anchor" href="#建议-1"><span>建议</span></a></h4><ul><li><strong>合理规划集群大小</strong>：根据业务需求和负载情况，合理规划集群的节点数量。</li><li><strong>分层管理</strong>：对大型集群，可以考虑分层管理，例如分为多个逻辑集群。</li></ul><h3 id="_4-设置-topic-的分区数量和副本数量" tabindex="-1"><a class="header-anchor" href="#_4-设置-topic-的分区数量和副本数量"><span>4. 设置 Topic 的分区数量和副本数量</span></a></h3><h4 id="分区数量的设置" tabindex="-1"><a class="header-anchor" href="#分区数量的设置"><span>分区数量的设置</span></a></h4><p>分区数量影响并行处理能力和负载均衡：</p><ul><li><strong>提高并行处理能力</strong>：更多的分区意味着更多的并行处理能力。</li><li><strong>均衡负载</strong>：分区数量应能均匀分布在所有 Broker 上。</li></ul><h4 id="设置分区数量的建议" tabindex="-1"><a class="header-anchor" href="#设置分区数量的建议"><span>设置分区数量的建议</span></a></h4><ul><li><strong>并行度</strong>：根据生产者和消费者的并行度设置分区数量。</li><li><strong>负载均衡</strong>：确保分区数量能均匀分布在所有 Broker 上。例如，有 3 个 Broker，可以设置分区数量 为 3 的倍数。</li></ul><h4 id="副本数量的设置" tabindex="-1"><a class="header-anchor" href="#副本数量的设置"><span>副本数量的设置</span></a></h4><p>副本数量影响数据的高可用性和容错能力：</p><ul><li><strong>提高容错能力</strong>：更多的副本意味着更高的容错能力。</li><li><strong>资源开销</strong>：更多的副本会增加存储和网络开销。</li></ul><h4 id="设置副本数量的建议" tabindex="-1"><a class="header-anchor" href="#设置副本数量的建议"><span>设置副本数量的建议</span></a></h4><ul><li><strong>高可用性</strong>：根据业务需求设置副本数量。一般来说，副本数量设置为 3 可以容忍 1 个节点故障。</li><li><strong>资源平衡</strong>：确保副本数量小于等于 Broker 数量。</li></ul><h3 id="核心代码和配置示例" tabindex="-1"><a class="header-anchor" href="#核心代码和配置示例"><span>核心代码和配置示例</span></a></h3><h4 id="创建-topic-并设置分区和副本" tabindex="-1"><a class="header-anchor" href="#创建-topic-并设置分区和副本"><span>创建 Topic 并设置分区和副本</span></a></h4><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="line">bin/kafka-topics.sh <span class="token parameter variable">--create</span> <span class="token parameter variable">--topic</span> my_topic --bootstrap-server localhost:9092 <span class="token parameter variable">--partitions</span> <span class="token number">6</span> --replication-factor <span class="token number">3</span></span>\n<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h4 id="修改消息大小限制的配置" tabindex="-1"><a class="header-anchor" href="#修改消息大小限制的配置"><span>修改消息大小限制的配置</span></a></h4><div class="language-properties line-numbers-mode" data-highlighter="prismjs" data-ext="properties" data-title="properties"><pre class="language-properties"><code><span class="line"><span class="token comment"># server.properties</span></span>\n<span class="line"><span class="token key attr-name">message.max.bytes</span><span class="token punctuation">=</span><span class="token value attr-value">10485760  # 将单条消息的最大大小设置为 10 MB</span></span>\n<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_5-实际应用中的考虑" tabindex="-1"><a class="header-anchor" href="#_5-实际应用中的考虑"><span>5. 实际应用中的考虑</span></a></h3><h4 id="集群规模和性能" tabindex="-1"><a class="header-anchor" href="#集群规模和性能"><span>集群规模和性能</span></a></h4><ul><li><strong>小型集群</strong>：3-10 个节点，适用于中小型企业和应用。</li><li><strong>中型集群</strong>：10-50 个节点，适用于中大型企业和高负载应用。</li><li><strong>大型集群</strong>：50 个节点以上，适用于大型企业和互联网公司。</li></ul><h4 id="监控和维护" tabindex="-1"><a class="header-anchor" href="#监控和维护"><span>监控和维护</span></a></h4><ul><li><strong>监控工具</strong>：使用 Kafka 的监控工具和指标（如 Kafka Manager、Prometheus + Grafana）监控集群状态。</li><li><strong>维护策略</strong>：定期检查集群状态，优化配置，及时处理故障。</li></ul><h3 id="_6-实例分析" tabindex="-1"><a class="header-anchor" href="#_6-实例分析"><span>6. 实例分析</span></a></h3><p>假设有一个 Kafka 集群，有 6 个 Broker，需要创建一个名为 <code>example_topic</code> 的 Topic，预计每秒处理 10000 条消息，并希望在保证高可用性的同时实现高性能。</p><h4 id="配置建议" tabindex="-1"><a class="header-anchor" href="#配置建议"><span>配置建议</span></a></h4><ul><li><strong>分区数量</strong>：12（保证每个 Broker 至少管理 2 个分区，充分利用并行处理能力）。</li><li><strong>副本数量</strong>：3（保证数据的高可用性，可以容忍 1 个节点故障）。</li></ul><h4 id="创建-topic-的命令" tabindex="-1"><a class="header-anchor" href="#创建-topic-的命令"><span>创建 Topic 的命令</span></a></h4><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="line">bin/kafka-topics.sh <span class="token parameter variable">--create</span> <span class="token parameter variable">--topic</span> example_topic --bootstrap-server localhost:9092 </span>\n<span class="line"><span class="token parameter variable">--partitions</span> <span class="token number">12</span> --replication-factor <span class="token number">3</span></span>\n<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="配置文件中的示例" tabindex="-1"><a class="header-anchor" href="#配置文件中的示例"><span>配置文件中的示例</span></a></h4><div class="language-properties line-numbers-mode" data-highlighter="prismjs" data-ext="properties" data-title="properties"><pre class="language-properties"><code><span class="line"><span class="token comment"># server.properties</span></span>\n<span class="line"><span class="token key attr-name">message.max.bytes</span><span class="token punctuation">=</span><span class="token value attr-value">10485760  # 将单条消息的最大大小设置为 10 MB</span></span>\n<span class="line"><span class="token key attr-name">log.retention.hours</span><span class="token punctuation">=</span><span class="token value attr-value">168     # 日志保留时间设置为 7 天</span></span>\n<span class="line"><span class="token key attr-name">num.partitions</span><span class="token punctuation">=</span><span class="token value attr-value">12           # 默认分区数量</span></span>\n<span class="line"><span class="token key attr-name">default.replication.factor</span><span class="token punctuation">=</span><span class="token value attr-value">3 # 默认副本数量</span></span>\n<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_7-总结" tabindex="-1"><a class="header-anchor" href="#_7-总结"><span>7. 总结</span></a></h3><ul><li><strong>Topic 数量</strong>：Kafka 对 Topic 数量没有硬性限制，但受限于 ZooKeeper 和 Broker 资源。</li><li><strong>消息大小</strong>：默认单条消息最大大小为 1 MB，可以通过配置调整。</li><li><strong>集群节点数量</strong>：没有硬性上限，但需要合理规划以避免网络和协调开销。</li><li><strong>分区数量</strong>：根据并行处理能力和负载均衡需求设置。</li><li><strong>副本数量</strong>：根据高可用性和容错需求设置。</li></ul><p>通过合理设置这些参数，可以优化 Kafka 集群的性能和可靠性，确保其在高并发和高负载情况下稳定运行。</p><h3 id="为什么数量设置为3" tabindex="-1"><a class="header-anchor" href="#为什么数量设置为3"><span>为什么数量设置为3？</span></a></h3><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre class="language-text"><code><span class="line">上述副本数量设置为3，如果一个节点故障，会从剩余两个节点选择一个为leader,假如剩余的leader故障，</span>\n<span class="line">还有一个节点是否可以正常对外提供服务，如果剩余的folower节点故障，难道不是还有一个节点可以正常提</span>\n<span class="line">供服务吗？</span>\n<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>副本数量（replication factor）为 3 是一种常见的配置，但不是最小值。这个配置选择的原因在于它能 够在保证数据高可用性的同时提供容错能力。下面详细解释为什么副本数量为 3 可以容忍一个节点故障，以 及其他相关的配置选择。</p><h3 id="_1-副本数量-replication-factor-的最小值" tabindex="-1"><a class="header-anchor" href="#_1-副本数量-replication-factor-的最小值"><span>1. 副本数量（Replication Factor）的最小值</span></a></h3><p>Kafka 的副本数量最小可以设置为 1，但副本数量为 1 的情况下没有任何容错能力，因为数据只存在于一个 节点上。一旦这个节点发生故障，数据就无法访问。</p><h3 id="_2-副本数量为-3-的优势" tabindex="-1"><a class="header-anchor" href="#_2-副本数量为-3-的优势"><span>2. 副本数量为 3 的优势</span></a></h3><p>副本数量为 3 是一种权衡数据高可用性和资源开销的常见配置。它的主要优势包括：</p><ul><li><strong>容错能力</strong>：能够容忍最多一个节点故障。</li><li><strong>数据高可用性</strong>：即使一个节点故障，数据仍然可以通过其他两个节点访问。</li><li><strong>ISR 列表</strong>：ISR（In-Sync Replica）列表包含所有与 Leader 保持同步的副本，保证了数据的一致性。</li></ul><h3 id="_3-容忍节点故障的原理" tabindex="-1"><a class="header-anchor" href="#_3-容忍节点故障的原理"><span>3. 容忍节点故障的原理</span></a></h3><h4 id="副本数量为-3-时的容错能力" tabindex="-1"><a class="header-anchor" href="#副本数量为-3-时的容错能力"><span>副本数量为 3 时的容错能力</span></a></h4><p>假设一个分区有 3 个副本，分布在 3 个不同的节点上：</p><ul><li><strong>正常状态</strong>：3 个副本中，一个是 Leader，两个是 Follower。</li><li><strong>一个节点故障</strong>：假设 Leader 节点故障，Kafka 会从剩下的 2 个 Follower 副本中选举新的 Leader。</li></ul><p>这种配置可以容忍一个节点故障，因为剩余的 2 个副本能够保证数据的可用性和一致性。</p><h3 id="_4-副本数量与节点故障的关系" tabindex="-1"><a class="header-anchor" href="#_4-副本数量与节点故障的关系"><span>4. 副本数量与节点故障的关系</span></a></h3><h4 id="副本数量与容错能力的关系" tabindex="-1"><a class="header-anchor" href="#副本数量与容错能力的关系"><span>副本数量与容错能力的关系</span></a></h4><ul><li><strong>副本数量 1</strong>：无容错能力，节点故障即数据不可用。</li><li><strong>副本数量 2</strong>：能够容忍一个节点故障，但不推荐，因为这时仅剩一个副本，无法再提供副本冗余。</li><li><strong>副本数量 3</strong>：能够容忍一个节点故障，同时保持高可用性和数据冗余。</li><li><strong>副本数量 n</strong>：能够容忍 n-1 个节点故障，但资源开销较大，需要权衡。</li></ul><h3 id="_5-为什么副本数量为-3-可以容忍一个节点故障" tabindex="-1"><a class="header-anchor" href="#_5-为什么副本数量为-3-可以容忍一个节点故障"><span>5. 为什么副本数量为 3 可以容忍一个节点故障</span></a></h3><h4 id="数据同步和-isr-列表" tabindex="-1"><a class="header-anchor" href="#数据同步和-isr-列表"><span>数据同步和 ISR 列表</span></a></h4><p>Kafka 使用 ISR 列表管理同步状态。ISR 列表包含所有与 Leader 保持同步的副本。只有当消息被写入到所有 ISR 副本后，Leader 才确认消息提交。</p><h4 id="副本数量为-3-的情况下的-isr-列表" tabindex="-1"><a class="header-anchor" href="#副本数量为-3-的情况下的-isr-列表"><span>副本数量为 3 的情况下的 ISR 列表</span></a></h4><ul><li><strong>正常状态</strong>：3 个副本（1 个 Leader + 2 个 Follower）都在 ISR 列表中。</li><li><strong>一个节点故障</strong>：假设 Leader 节点故障，Kafka 会从 ISR 列表中的 2 个 Follower 副本中选举新的 Leader。</li></ul><p>这种情况下，即使一个节点故障，剩余的 2 个副本仍在 ISR 列表中，能够保证数据一致性和高可用性。</p><h3 id="_6-核心代码示例" tabindex="-1"><a class="header-anchor" href="#_6-核心代码示例"><span>6. 核心代码示例</span></a></h3><p>以下是管理 ISR 列表的核心代码示例：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token comment">// Partition.scala</span></span>\n<span class="line"><span class="token keyword">class</span> <span class="token class-name">Partition</span><span class="token punctuation">(</span>val topicPartition<span class="token operator">:</span> <span class="token class-name">TopicPartition</span><span class="token punctuation">,</span> val leader<span class="token operator">:</span> <span class="token class-name">Int</span><span class="token punctuation">,</span> val replicas<span class="token operator">:</span> <span class="token class-name">List</span><span class="token punctuation">[</span><span class="token class-name">Int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>\n<span class="line">    val isr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicReference</span><span class="token punctuation">[</span><span class="token class-name">List</span><span class="token punctuation">[</span><span class="token class-name">Int</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">(</span>replicas<span class="token punctuation">)</span></span>\n<span class="line"></span>\n<span class="line">    def <span class="token function">addToIsr</span><span class="token punctuation">(</span>replicaId<span class="token operator">:</span> <span class="token class-name">Int</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token class-name">Unit</span> <span class="token operator">=</span> <span class="token punctuation">{</span></span>\n<span class="line">        val currentIsr <span class="token operator">=</span> isr<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>\n<span class="line">        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>currentIsr<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>replicaId<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>\n<span class="line">            isr<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>replicaId <span class="token operator">::</span> <span class="token function">currentIsr</span><span class="token punctuation">)</span></span>\n<span class="line">        <span class="token punctuation">}</span></span>\n<span class="line">    <span class="token punctuation">}</span></span>\n<span class="line"></span>\n<span class="line">    def <span class="token function">removeFromIsr</span><span class="token punctuation">(</span>replicaId<span class="token operator">:</span> <span class="token class-name">Int</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token class-name">Unit</span> <span class="token operator">=</span> <span class="token punctuation">{</span></span>\n<span class="line">        val currentIsr <span class="token operator">=</span> isr<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>\n<span class="line">        <span class="token keyword">if</span> <span class="token punctuation">(</span>currentIsr<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>replicaId<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>\n<span class="line">            isr<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>currentIsr<span class="token punctuation">.</span><span class="token function">filterNot</span><span class="token punctuation">(</span>_ <span class="token operator">==</span> replicaId<span class="token punctuation">)</span><span class="token punctuation">)</span></span>\n<span class="line">        <span class="token punctuation">}</span></span>\n<span class="line">    <span class="token punctuation">}</span></span>\n<span class="line"></span>\n<span class="line">    def <span class="token function">isInSync</span><span class="token punctuation">(</span>replicaId<span class="token operator">:</span> <span class="token class-name">Int</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token class-name">Boolean</span> <span class="token operator">=</span> <span class="token punctuation">{</span></span>\n<span class="line">        isr<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>replicaId<span class="token punctuation">)</span></span>\n<span class="line">    <span class="token punctuation">}</span></span>\n<span class="line"><span class="token punctuation">}</span></span>\n<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_7-副本数量的配置建议" tabindex="-1"><a class="header-anchor" href="#_7-副本数量的配置建议"><span>7. 副本数量的配置建议</span></a></h3><ul><li><strong>最小副本数量</strong>：根据业务需求和资源情况，最小副本数量通常为 3，以保证高可用性和容错能力。</li><li><strong>资源和性能权衡</strong>：副本数量越多，资源开销越大，设置时需要权衡性能和资源利用。</li></ul><h3 id="_8-配置示例" tabindex="-1"><a class="header-anchor" href="#_8-配置示例"><span>8. 配置示例</span></a></h3><p>创建一个副本数量为 3 的 Topic：</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="line">bin/kafka-topics.sh <span class="token parameter variable">--create</span> <span class="token parameter variable">--topic</span> my_topic --bootstrap-server localhost:9092 <span class="token parameter variable">--partitions</span> <span class="token number">6</span> --replication-factor <span class="token number">3</span></span>\n<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h3><ul><li><strong>副本数量为 3 的优势</strong>：能够在保证数据高可用性的同时提供容错能力，是一种常见的配置选择。</li><li><strong>容错能力原理</strong>：副本数量为 3 时，能够容忍一个节点故障，同时保持数据的一致性和高可用性。</li><li><strong>配置建议</strong>：根据业务需求和资源情况，合理设置副本数量，通常建议为 3，以确保高可用性和容错能力。</li></ul><p>通过这些配置和机制，Kafka 能够在高并发和高负载的情况下，提供高性能、高可用性和高可靠性的消息服务。</p>',83)],t={},p=(0,n(6262).A)(t,[["render",function(a,s){return(0,e.uX)(),(0,e.CE)("div",null,l)}]]),i=JSON.parse('{"path":"/blog/kafka/Kafka-%E9%9B%86%E7%BE%A4Topic%E3%80%81%E6%B6%88%E6%81%AF%E5%A4%A7%E5%B0%8F%E3%80%81%E8%8A%82%E7%82%B9%E6%A0%BC%E5%BC%8F%E4%B8%8A%E9%99%90%E7%AE%A1%E6%8E%A7%E5%8E%9F%E7%90%86.html","title":"Kafka 集群 Topic、消息大小、节点格式上限管控原理","lang":"zh-CN","frontmatter":{"date":"2021-07-07T00:00:00.000Z","category":["Kafka"],"tag":["消息队列"],"sticky":true,"excerpt":"<p>Kafka 集群原理设计分析</p>"},"headers":[{"level":3,"title":"1. Kafka 集群对创建 Topic 的数量限制","slug":"_1-kafka-集群对创建-topic-的数量限制","link":"#_1-kafka-集群对创建-topic-的数量限制","children":[]},{"level":3,"title":"2. Kafka 发送的消息内容大小限制","slug":"_2-kafka-发送的消息内容大小限制","link":"#_2-kafka-发送的消息内容大小限制","children":[]},{"level":3,"title":"3. Kafka 集群节点的个数限制","slug":"_3-kafka-集群节点的个数限制","link":"#_3-kafka-集群节点的个数限制","children":[]},{"level":3,"title":"4. 设置 Topic 的分区数量和副本数量","slug":"_4-设置-topic-的分区数量和副本数量","link":"#_4-设置-topic-的分区数量和副本数量","children":[]},{"level":3,"title":"核心代码和配置示例","slug":"核心代码和配置示例","link":"#核心代码和配置示例","children":[]},{"level":3,"title":"5. 实际应用中的考虑","slug":"_5-实际应用中的考虑","link":"#_5-实际应用中的考虑","children":[]},{"level":3,"title":"6. 实例分析","slug":"_6-实例分析","link":"#_6-实例分析","children":[]},{"level":3,"title":"7. 总结","slug":"_7-总结","link":"#_7-总结","children":[]},{"level":3,"title":"为什么数量设置为3？","slug":"为什么数量设置为3","link":"#为什么数量设置为3","children":[]},{"level":3,"title":"1. 副本数量（Replication Factor）的最小值","slug":"_1-副本数量-replication-factor-的最小值","link":"#_1-副本数量-replication-factor-的最小值","children":[]},{"level":3,"title":"2. 副本数量为 3 的优势","slug":"_2-副本数量为-3-的优势","link":"#_2-副本数量为-3-的优势","children":[]},{"level":3,"title":"3. 容忍节点故障的原理","slug":"_3-容忍节点故障的原理","link":"#_3-容忍节点故障的原理","children":[]},{"level":3,"title":"4. 副本数量与节点故障的关系","slug":"_4-副本数量与节点故障的关系","link":"#_4-副本数量与节点故障的关系","children":[]},{"level":3,"title":"5. 为什么副本数量为 3 可以容忍一个节点故障","slug":"_5-为什么副本数量为-3-可以容忍一个节点故障","link":"#_5-为什么副本数量为-3-可以容忍一个节点故障","children":[]},{"level":3,"title":"6. 核心代码示例","slug":"_6-核心代码示例","link":"#_6-核心代码示例","children":[]},{"level":3,"title":"7. 副本数量的配置建议","slug":"_7-副本数量的配置建议","link":"#_7-副本数量的配置建议","children":[]},{"level":3,"title":"8. 配置示例","slug":"_8-配置示例","link":"#_8-配置示例","children":[]},{"level":3,"title":"总结","slug":"总结","link":"#总结","children":[]}],"git":{"updatedTime":1720877624000,"contributors":[{"name":"asus","email":"939943844@qq.com","commits":1}]},"filePathRelative":"blog/kafka/Kafka-集群Topic、消息大小、节点格式上限管控原理.md"}')}}]);